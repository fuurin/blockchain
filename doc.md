# ブロックチェーンをやってみたい

参考にしたのはこのQiita(2019/06/24)
[ブロックチェーンを作ることで学ぶ 〜ブロックチェーンがどのように動いているのか学ぶ最速の方法は作ってみることだ〜](https://qiita.com/hidehiro98/items/841ece65d896aeaa8a2a)

概念的な説明はここも見たが，結局よくわからなかった
[ブロックチェーンの仕組み　〜初心者のためのわかりやすい解説〜](https://gaiax-blockchain.com/blockchain-first-book)


Qiitaの概要

## ブロックチェーンを書く
まずはBlockchainクラスの骨組みを作る
- Blockchain
  - init
  - new_block
  - new_transaction
  - hash (ブロックをハッシュ化)
  - last_block

## ブロックとはどのようなものか
``` json
block = {
    'index': 1,
    'timestamp': 1506057125.900785,
    'transactions': [
        {
            'sender': "8527147fe1f5426f9dd545de4b27ee00",
            'recipient': "a77f5cdfa2934df3954a5c7c7da5df1f",
            'amount': 5,
        }
    ],
    'proof': 324984774000,
    'previous_hash': "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
}
```

全ての新しいブロックはそれまでの全てのブロックから生成されるハッシュを持つ．  
これがブロックチェーンに不変性を与える，重要なポイント
チェーン初期のブロックが改ざんされたとき，それに続く全てのブロックが不正なハッシュを含みことになる．
  
(囲碁の劫を防ぐため，盤面をハッシュ化してそれまでの履歴を全て辿るゾブリストハッシュのように，ハッシュを応用したチェック効率化の手法のようである．)  
  

## トランザクションをブロックに加える
- new_transaction実装
  - 送信者，受信者，量(金額とか)からなるトランザクションをブロックに追加

## 新しいブロックを作る
- init
  - ジェネシスブロックを作り初期化
- new_block実装
  - トランザクションを入れる箱であるブロックを新規作成し，チェーンに加える
- last_block実装
- hash実装
  - 与えられたブロックをjson文字列→SHA-256ハッシュに変換して返す

## プルーフオブワーク(PoW)を理解する
「仕事の証明」そのトランザクションが正常に行われたかを検証する方法のこと  
ブロックチェーン上でどのように新しいブロックが作られる=採掘されるかを表す  
PoWの目的は，問題を解く番号を発見すること  
その番号は，「見つけるのは難しく，確認するのは簡単」な必要がある  
  
例  
x * y のハッシュ値が0で終わらないといけないというルールを定める  
ルールが守られていれば正常に仕事が行われ，そうでなければ改ざんがあったと考える  

``` python
x = 5
y = 0 # まだこのyがどの数字であるべきかはわからない

# x*yのハッシュ値が0で終わるようなyを探す
# 見つけるのは難しい(もっとルールが厳しくなれば相当時間がかかる)
# 確認するのは簡単．(ハッシュ値の最後が0かを見るだけ)
while sha256(f'{x * y}'.encode()).hexdigest()[-1] != '0':
    y += 1

print(f'The solution is y = {y}')
```

解は y = 21

上記の例のようなプルーフオブワークのアルゴリズムを「ハッシュキャッシュ」と呼ぶ  
ハッシュ値を使った複雑なパリティチェックと似ている．

# 基本的なPoWを実装する
- proof_of_work実装
  - 前のハッシュ値に対し，条件を満たすような番号を1ずつ増やしながら探す
- valid_proof実装
  - ここでは，ハッシュ値の頭4つが0であるようなハッシュ値をOKとする．
  - 2つの番号から生成したハッシュ値がOKのときTrue,そうでないときFalseを返す  

ハッシュの頭に必要な0の数を増やすごとに，どんどん時間がかかるようになってゆく  
キーを作るのは難しいが，ルールを守っているかを調べるのは簡単！  

# APIとしての私たちのブロックチェーン
FlaskでBlockchainを使うAPIを作ってみよう

エンドポイント
- /transactions/new
  - POST
  - ブロックへの新しいトランザクションを作る
  - POSTされた値をチェックしてnew_transactionに渡すだけ

- /mine
  - GET
  - 新しいブロックを採掘(トランザクションを入れる箱を作る)する
    - ブロックのトランザクション全体の正しさを示すため，PoWを計算
    - ブロックのトランザクションの最後に区切りを示す特別なトランザクションを追加
      - 採掘者には1コインの利益を与える（ナゼ？）
      - 採掘，とはおそらく，PoWに則るハッシュ値を発見できたという意味合い
    - 新たなブロックにPoWを渡して作成し，チェーンに追加

- /chain
  - GET
  - ブロックチェーンの全ての情報を返す

トランザクションを作るときには，次のようなJSONをサーバに送信する
``` json
{
    sender: "my address",
    recipient: "someone else's address",
    amount: 5
}
```

## オリジナルブロックチェーンとのインタラクション

採掘する

``` bash
(blockchain) mac% curl http://localhost:5000/mine
{
  "index": 2, 
  "message": "New Block Forged", 
  "previous_hash": "3ead50f28ce6f9511a9abb86a59e32b96c949f22a056f5e3e847754b29957693", 
  "proof": 35293, 
  "transactions": [
    {
      "amount": 1, 
      "recipient": "7cffff89bc8e4e6ba2e5ec266a99dc7b", 
      "sender": "0"
    }
  ]
}
```

最初のブロックの次にブロックを作っていたので，今PoWが完了したindexは2

今のブロック(index: 3)にtransactionを追加してみる

``` bash
(blockchain) mac% curl -X POST -H "Content-Type: application/json" -d '{"sender": "7cffff89bc8e4e6ba2e5ec266a99dc7b", "recipient": "someone-other-address", "amount": 5 }' "http://localhost:5000/transactions/new"
{
  "message": "Transaction appended into the block 3"
}
```

ここまでのチェーン全体を見てみる

``` bash
(blockchain) mac% curl http://localhost:5000/chain
{
  "chain": [
    {
      "index": 1, 
      "previous_hash": 1, 
      "proof": 100, 
      "timestamp": 1562516766.5790899, 
      "transactions": []
    }, 
    {
      "index": 2, 
      "previous_hash": "3ead50f28ce6f9511a9abb86a59e32b96c949f22a056f5e3e847754b29957693", 
      "proof": 35293, 
      "timestamp": 1562516770.61996, 
      "transactions": [
        {
          "amount": 1, 
          "recipient": "7cffff89bc8e4e6ba2e5ec266a99dc7b", 
          "sender": "0"
        }
      ]
    }
  ], 
  "length": 2
}
```

まだblock3はPoWがないのでチェーンに追加されていない

## コンセンサス
ここまで，トランザクションをまとめてブロックとして採掘できるようになった  
  
ブロックチェーンの重要なポイントは，非中央集権的であること．  
非中央集権的なときに全員が同じチェーンを反映していると確認する問題がある  
これをコンセンサスの問題と呼び，そのアルゴリズムを実装する．  

## 新しいノードを登録する
各人員，またはその人たちのマシンを「ノード」と呼ぶ  
Blockchainクラスにノードを登録できるようにする

- __init__ でself.nodes = set()
- nodesに新しいノードのアドレスを加える registar_node を実装 

## コンセンサスアルゴリズムを実装する
コンフリクトはあるノードが他のノードと異なったチェーンを持っていると発生  
ここでは，「最も長い正常なチェーンが信頼できる」というルールを作る  

Blockchianクラスにコンセンサスアルゴリズムを追加
- valid_chian: ブロックチェーンが正しいかを確認する
  - 前のブロックのハッシュが次のブロックに正しく伝わっていること
  - 前後のPoW間でルールが守られていること(ハッシュとったら)
- resolve_conflicts: 全てのノードとコンセンサスをとる
  - ネットワーク上の最も長いチェーンを自らのチェーンと置き換える
  - valid_chainを使い，Trueであることが必要

そしてノードに関連するエンドポイントを追加する  
- /nodes/register
  - POST
  - 新しいノードのリストを受け取り，register_nodeに渡して呼び出す
- /nodes/resolve
  - GET
  - resolve_conflictsを呼び出した結果
  - あらゆるコンフリクトを解消し，ノードが正しいチェーンを持っていることを確認
  
  
それではコンセンサスを試してみる  
まずは2つのノードを立ち上げる  
ポート番号を指定できるようsys.argvを使う  
  
``` bash
# ターミナルその1
mac% python app.py 5000

# ターミナルその2
mac% python app.py 5001
```
  
次に，5000に別の他のノードの存在を教えるため，nodes/registerへPOST  
  
``` bash
mac% curl -X POST -H "Content-Type: application/json" -d '{
    "nodes": ["http://localhost:5001"]
}' "http://localhost:5000/nodes/register"

{
  "message": "New node added", 
  "total_nodes": [
    "localhost:5001"
  ]
}
```

5001のチェーンが長くなるように，いくつかmine

``` bash
mac% curl "http://localhost:5001/mine"
mac% curl "http://localhost:5001/mine"
...
```

ここで，5000のnodes/resolveを呼び出すことで，5001の長いチェーンを受け取る

``` bash
mac% curl "http://localhost:5000/nodes/resolve"            
{
  "message": "Chain is replaced", 
  "new_chain": [
    {
      "index": 1, 
      "previous_hash": 1, 
      "proof": 100, 
      "timestamp": 1562574201.189295, 
      "transactions": []
    }, 
    {
      "index": 2, 
      "previous_hash": "c23d4bcc321fe40e8b5f69f5db7d92bfeb220ea3da109a2aee75610154a3adda", 
      "proof": 35293, 
      "timestamp": 1562574209.541226, 
      "transactions": [
        {
          "amount": 1, 
          "recipient": "418b27323e564c3a9fa2274fce5b30e0", 
          "sender": "0"
        }
      ]
    }, 
    {
      "index": 3, 
      "previous_hash": "fe7a21bfe24ab8b337c2758a3b99ae6ef5c4a9cc1f9d5f41ae01619dd2c5af36", 
      "proof": 35089, 
      "timestamp": 1562574210.187649, 
      "transactions": [
        {
          "amount": 1, 
          "recipient": "418b27323e564c3a9fa2274fce5b30e0", 
          "sender": "0"
        }
      ]
    }
  ]
}
```

なお，新しいトランザクションは全ノードに送信される．  
以上のようにして，P2P的にブロックチェーンの共有に成功した．

## まとめ
これが大体のブロックチェーンの基本かと．  
応用として
- 経済
- 行政
- 記録の保管
- もちろん暗号通貨
がある．  

さらに，パート2が計画中らしい．  
- トランザクションの確認メカニズム
- ブロックチェーンのさらなる応用

## ブロックチェーンの必要要件のまとめ
ブロックチェーンとは結局なんなのか？  
  
- ブロックチェーンの構成
  - ブロックチェーンとは，ブロックというものを時系列順に並べたリスト  
  - ブロックとは，主にいくつかのトランザクションを格納するデータである  
  - トランザクションには，例えばお金の受け渡し情報が含まれる  

- ブロックチェーンは，ブロックのデータの改ざんを防げる
  - ブロックチェーンの各ブロックの前後間には，改ざんを防ぐためのルールがある  
  - 例えば，前のブロックの情報と今のブロックの情報を使ったハッシュ値を使う  
  - このハッシュ値は，例えば先頭が"0000"でなければならないルールがある  
  - 今のブロックは，前のブロックに対してそのハッシュ値を発見し，保持する．  
  - このハッシュ値を発見し，新たなブロックを生成することを採掘と呼ぶ
  - これにより，今のブロックの情報が改ざんされれば，前のブロックも，ハッシュ値を0000になるよう改ざんする必要があり，その前も前も...となって，改ざんを防げる．
  - この前後ルールは，合っているか確認するのは簡単だが，合わせるのは難しい．
  - この仕組みを，プルーフオブワーク，PoWと呼ぶ．
     
- ブロックチェーンのユーザは全員，最新のチェーンを見ることができる
  - このユーザ各員，または彼らの各マシンをノードとも呼ぶ
  - 各ノードは，ネットワーク上の全ノードの存在を知っている
  - 全てのノードのチェーンにアクセスし，一番長いチェーンを自分の所にコピーする
  - コピーされるチェーンは，全てのブロックのPoWが正常である必要がある．
  - この操作をコンセンサスと呼ぶ
  - 新しいトランザクションは全ノードに送信される
  - ブロックの採掘前にコンセンサスを取れば，全員最新のチェーンにブロックを加えていける
  
以上が，この記事が説明する，ブロックチェーンに求められることである．